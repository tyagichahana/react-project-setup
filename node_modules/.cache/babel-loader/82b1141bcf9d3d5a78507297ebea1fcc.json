{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nfunction t() {\n  var data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function t() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  var type = this._getTypeAnnotation() || t().anyTypeAnnotation();\n  if (t().isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nfunction _getTypeAnnotation() {\n  var node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      var declar = this.parentPath.parentPath;\n      var declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t().stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t().anyTypeAnnotation();\n      }\n\n      return t().voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  var inferer = inferers[node.type];\n\n  if (inferer) {\n    return inferer.call(this, node);\n  }\n\n  inferer = inferers[this.parentPath.type];\n\n  if (inferer && inferer.validParent) {\n    return this.parentPath.getTypeAnnotation();\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t().isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t().isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t().isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t().isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t().isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t().isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t().isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(\"Unknown base type \".concat(baseName));\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  var type = this.getTypeAnnotation();\n  if (t().isAnyTypeAnnotation(type)) return true;\n\n  if (t().isUnionTypeAnnotation(type)) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = type.types[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var type2 = _step.value;\n\n        if (t().isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(right) {\n  var left = this.getTypeAnnotation();\n  right = right.getTypeAnnotation();\n\n  if (!t().isAnyTypeAnnotation(left) && t().isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n}\n\nfunction isGenericType(genericName) {\n  var type = this.getTypeAnnotation();\n  return t().isGenericTypeAnnotation(type) && t().isIdentifier(type.id, {\n    name: genericName\n  });\n}","map":null,"metadata":{},"sourceType":"script"}