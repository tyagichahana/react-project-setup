{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/chahanatyagi/Work/cm-frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/chahanatyagi/Work/cm-frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nfunction _helperSplitExportDeclaration() {\n  var data = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\n  _helperSplitExportDeclaration = function _helperSplitExportDeclaration() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction t() {\n  var data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function t() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar renameVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {\n    var node = _ref.node;\n\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n  Scope: function Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n    }\n  },\n  \"AssignmentExpression|Declaration\": function AssignmentExpressionDeclaration(path, state) {\n    var ids = path.getOuterBindingIdentifiers();\n\n    for (var name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n};\n\nvar Renamer =\n/*#__PURE__*/\nfunction () {\n  function Renamer(binding, oldName, newName) {\n    _classCallCheck(this, Renamer);\n\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  _createClass(Renamer, [{\n    key: \"maybeConvertFromExportDeclaration\",\n    value: function maybeConvertFromExportDeclaration(parentDeclar) {\n      var maybeExportDeclar = parentDeclar.parentPath;\n\n      if (!maybeExportDeclar.isExportDeclaration()) {\n        return;\n      }\n\n      if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n        return;\n      }\n\n      (0, _helperSplitExportDeclaration().default)(maybeExportDeclar);\n    }\n  }, {\n    key: \"maybeConvertFromClassFunctionDeclaration\",\n    value: function maybeConvertFromClassFunctionDeclaration(path) {\n      return;\n      if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n      if (this.binding.kind !== \"hoisted\") return;\n      path.node.id = t().identifier(this.oldName);\n      path.node._blockHoist = 3;\n      path.replaceWith(t().variableDeclaration(\"let\", [t().variableDeclarator(t().identifier(this.newName), t().toExpression(path.node))]));\n    }\n  }, {\n    key: \"maybeConvertFromClassFunctionExpression\",\n    value: function maybeConvertFromClassFunctionExpression(path) {\n      return;\n      if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n      if (this.binding.kind !== \"local\") return;\n      path.node.id = t().identifier(this.oldName);\n      this.binding.scope.parent.push({\n        id: t().identifier(this.newName)\n      });\n      path.replaceWith(t().assignmentExpression(\"=\", t().identifier(this.newName), path.node));\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(block) {\n      var binding = this.binding,\n          oldName = this.oldName,\n          newName = this.newName;\n      var scope = binding.scope,\n          path = binding.path;\n      var parentDeclar = path.find(function (path) {\n        return path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression();\n      });\n\n      if (parentDeclar) {\n        var bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n        if (bindingIds[oldName] === binding.identifier) {\n          this.maybeConvertFromExportDeclaration(parentDeclar);\n        }\n      }\n\n      scope.traverse(block || scope.block, renameVisitor, this);\n\n      if (!block) {\n        scope.removeOwnBinding(oldName);\n        scope.bindings[newName] = binding;\n        this.binding.identifier.name = newName;\n      }\n\n      if (binding.type === \"hoisted\") {}\n\n      if (parentDeclar) {\n        this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n        this.maybeConvertFromClassFunctionExpression(parentDeclar);\n      }\n    }\n  }]);\n\n  return Renamer;\n}();\n\nexports.default = Renamer;","map":null,"metadata":{},"sourceType":"script"}