{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/chahanatyagi/Work/cm-frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPresetChain = buildPresetChain;\nexports.buildRootChain = buildRootChain;\nexports.buildPresetChainWalker = void 0;\n\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  var data = _interopRequireDefault(require(\"debug\"));\n\n  _debug = function _debug() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./validation/options\");\n\nvar _patternToRegex = _interopRequireDefault(require(\"./pattern-to-regex\"));\n\nvar _files = require(\"./files\");\n\nvar _caching = require(\"./caching\");\n\nvar _configDescriptors = require(\"./config-descriptors\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar debug = (0, _debug().default)(\"babel:config:config-chain\");\n\nfunction buildPresetChain(arg, context) {\n  var chain = buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options\n  };\n}\n\nvar buildPresetChainWalker = makeChainWalker({\n  init: function init(arg) {\n    return arg;\n  },\n  root: function root(preset) {\n    return loadPresetDescriptors(preset);\n  },\n  env: function env(preset, envName) {\n    return loadPresetEnvDescriptors(preset)(envName);\n  },\n  overrides: function overrides(preset, index) {\n    return loadPresetOverridesDescriptors(preset)(index);\n  },\n  overridesEnv: function overridesEnv(preset, index, envName) {\n    return loadPresetOverridesEnvDescriptors(preset)(index)(envName);\n  }\n});\nexports.buildPresetChainWalker = buildPresetChainWalker;\nvar loadPresetDescriptors = (0, _caching.makeWeakCache)(function (preset) {\n  return buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors);\n});\nvar loadPresetEnvDescriptors = (0, _caching.makeWeakCache)(function (preset) {\n  return (0, _caching.makeStrongCache)(function (envName) {\n    return buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName);\n  });\n});\nvar loadPresetOverridesDescriptors = (0, _caching.makeWeakCache)(function (preset) {\n  return (0, _caching.makeStrongCache)(function (index) {\n    return buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index);\n  });\n});\nvar loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCache)(function (preset) {\n  return (0, _caching.makeStrongCache)(function (index) {\n    return (0, _caching.makeStrongCache)(function (envName) {\n      return buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName);\n    });\n  });\n});\n\nfunction buildRootChain(opts, context) {\n  var programmaticChain = loadProgrammaticChain({\n    options: opts,\n    dirname: context.cwd\n  }, context);\n  if (!programmaticChain) return null;\n  var configFile;\n\n  if (typeof opts.configFile === \"string\") {\n    configFile = (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);\n  } else if (opts.configFile !== false) {\n    configFile = (0, _files.findRootConfig)(context.root, context.envName, context.caller);\n  }\n\n  var babelrc = opts.babelrc,\n      babelrcRoots = opts.babelrcRoots;\n  var babelrcRootsDirectory = context.cwd;\n  var configFileChain = emptyChain();\n\n  if (configFile) {\n    var validatedFile = validateConfigFile(configFile);\n    var result = loadFileChain(validatedFile, context);\n    if (!result) return null;\n\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n\n    mergeChain(configFileChain, result);\n  }\n\n  var pkgData = typeof context.filename === \"string\" ? (0, _files.findPackageData)(context.filename) : null;\n  var ignoreFile, babelrcFile;\n  var fileChain = emptyChain();\n\n  if ((babelrc === true || babelrc === undefined) && pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {\n    var _ref = (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller);\n\n    ignoreFile = _ref.ignore;\n    babelrcFile = _ref.config;\n\n    if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {\n      return null;\n    }\n\n    if (babelrcFile) {\n      var _result = loadFileChain(validateBabelrcFile(babelrcFile), context);\n\n      if (!_result) return null;\n      mergeChain(fileChain, _result);\n    }\n  }\n\n  var chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(function (o) {\n      return normalizeOptions(o);\n    }),\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined\n  };\n}\n\nfunction babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n  var absoluteRoot = context.root;\n\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  var babelrcPatterns = babelrcRoots;\n  if (!Array.isArray(babelrcPatterns)) babelrcPatterns = [babelrcPatterns];\n  babelrcPatterns = babelrcPatterns.map(function (pat) {\n    return typeof pat === \"string\" ? _path().default.resolve(babelrcRootsDirectory, pat) : pat;\n  });\n\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  return babelrcPatterns.some(function (pat) {\n    if (typeof pat === \"string\") {\n      pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);\n    }\n\n    return pkgData.directories.some(function (directory) {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\n\nvar validateConfigFile = (0, _caching.makeWeakCache)(function (file) {\n  return {\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: (0, _options.validate)(\"configfile\", file.options)\n  };\n});\nvar validateBabelrcFile = (0, _caching.makeWeakCache)(function (file) {\n  return {\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: (0, _options.validate)(\"babelrcfile\", file.options)\n  };\n});\nvar validateExtendFile = (0, _caching.makeWeakCache)(function (file) {\n  return {\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: (0, _options.validate)(\"extendsfile\", file.options)\n  };\n});\nvar loadProgrammaticChain = makeChainWalker({\n  root: function root(input) {\n    return buildRootDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors);\n  },\n  env: function env(input, envName) {\n    return buildEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, envName);\n  },\n  overrides: function overrides(input, index) {\n    return buildOverrideDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index);\n  },\n  overridesEnv: function overridesEnv(input, index, envName) {\n    return buildOverrideEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index, envName);\n  }\n});\nvar loadFileChain = makeChainWalker({\n  root: function root(file) {\n    return loadFileDescriptors(file);\n  },\n  env: function env(file, envName) {\n    return loadFileEnvDescriptors(file)(envName);\n  },\n  overrides: function overrides(file, index) {\n    return loadFileOverridesDescriptors(file)(index);\n  },\n  overridesEnv: function overridesEnv(file, index, envName) {\n    return loadFileOverridesEnvDescriptors(file)(index)(envName);\n  }\n});\nvar loadFileDescriptors = (0, _caching.makeWeakCache)(function (file) {\n  return buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors);\n});\nvar loadFileEnvDescriptors = (0, _caching.makeWeakCache)(function (file) {\n  return (0, _caching.makeStrongCache)(function (envName) {\n    return buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName);\n  });\n});\nvar loadFileOverridesDescriptors = (0, _caching.makeWeakCache)(function (file) {\n  return (0, _caching.makeStrongCache)(function (index) {\n    return buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index);\n  });\n});\nvar loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCache)(function (file) {\n  return (0, _caching.makeStrongCache)(function (index) {\n    return (0, _caching.makeStrongCache)(function (envName) {\n      return buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName);\n    });\n  });\n});\n\nfunction buildRootDescriptors(_ref2, alias, descriptors) {\n  var dirname = _ref2.dirname,\n      options = _ref2.options;\n  return descriptors(dirname, options, alias);\n}\n\nfunction buildEnvDescriptors(_ref3, alias, descriptors, envName) {\n  var dirname = _ref3.dirname,\n      options = _ref3.options;\n  var opts = options.env && options.env[envName];\n  return opts ? descriptors(dirname, opts, \"\".concat(alias, \".env[\\\"\").concat(envName, \"\\\"]\")) : null;\n}\n\nfunction buildOverrideDescriptors(_ref4, alias, descriptors, index) {\n  var dirname = _ref4.dirname,\n      options = _ref4.options;\n  var opts = options.overrides && options.overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n  return descriptors(dirname, opts, \"\".concat(alias, \".overrides[\").concat(index, \"]\"));\n}\n\nfunction buildOverrideEnvDescriptors(_ref5, alias, descriptors, index, envName) {\n  var dirname = _ref5.dirname,\n      options = _ref5.options;\n  var override = options.overrides && options.overrides[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n  var opts = override.env && override.env[envName];\n  return opts ? descriptors(dirname, opts, \"\".concat(alias, \".overrides[\").concat(index, \"].env[\\\"\").concat(envName, \"\\\"]\")) : null;\n}\n\nfunction makeChainWalker(_ref6) {\n  var root = _ref6.root,\n      env = _ref6.env,\n      overrides = _ref6.overrides,\n      overridesEnv = _ref6.overridesEnv;\n  return function (input, context) {\n    var files = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    var dirname = input.dirname;\n    var flattenedConfigs = [];\n    var rootOpts = root(input);\n\n    if (configIsApplicable(rootOpts, dirname, context)) {\n      flattenedConfigs.push(rootOpts);\n      var envOpts = env(input, context.envName);\n\n      if (envOpts && configIsApplicable(envOpts, dirname, context)) {\n        flattenedConfigs.push(envOpts);\n      }\n\n      (rootOpts.options.overrides || []).forEach(function (_, index) {\n        var overrideOps = overrides(input, index);\n\n        if (configIsApplicable(overrideOps, dirname, context)) {\n          flattenedConfigs.push(overrideOps);\n          var overrideEnvOpts = overridesEnv(input, index, context.envName);\n\n          if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {\n            flattenedConfigs.push(overrideEnvOpts);\n          }\n        }\n      });\n    }\n\n    if (flattenedConfigs.some(function (_ref7) {\n      var _ref7$options = _ref7.options,\n          ignore = _ref7$options.ignore,\n          only = _ref7$options.only;\n      return shouldIgnore(context, ignore, only, dirname);\n    })) {\n      return null;\n    }\n\n    var chain = emptyChain();\n\n    for (var _i = 0; _i < flattenedConfigs.length; _i++) {\n      var op = flattenedConfigs[_i];\n\n      if (!mergeExtendsChain(chain, op.options, dirname, context, files)) {\n        return null;\n      }\n\n      mergeChainOpts(chain, op);\n    }\n\n    return chain;\n  };\n}\n\nfunction mergeExtendsChain(chain, opts, dirname, context, files) {\n  if (opts.extends === undefined) return true;\n  var file = (0, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);\n\n  if (files.has(file)) {\n    throw new Error(\"Configuration cycle detected loading \".concat(file.filepath, \".\\n\") + \"File already loaded following the config chain:\\n\" + Array.from(files, function (file) {\n      return \" - \".concat(file.filepath);\n    }).join(\"\\n\"));\n  }\n\n  files.add(file);\n  var fileChain = loadFileChain(validateExtendFile(file), context, files);\n  files.delete(file);\n  if (!fileChain) return false;\n  mergeChain(chain, fileChain);\n  return true;\n}\n\nfunction mergeChain(target, source) {\n  var _target$options, _target$plugins, _target$presets;\n\n  (_target$options = target.options).push.apply(_target$options, _toConsumableArray(source.options));\n\n  (_target$plugins = target.plugins).push.apply(_target$plugins, _toConsumableArray(source.plugins));\n\n  (_target$presets = target.presets).push.apply(_target$presets, _toConsumableArray(source.presets));\n\n  return target;\n}\n\nfunction mergeChainOpts(target, _ref8) {\n  var _target$plugins2, _target$presets2;\n\n  var options = _ref8.options,\n      plugins = _ref8.plugins,\n      presets = _ref8.presets;\n  target.options.push(options);\n\n  (_target$plugins2 = target.plugins).push.apply(_target$plugins2, _toConsumableArray(plugins()));\n\n  (_target$presets2 = target.presets).push.apply(_target$presets2, _toConsumableArray(presets()));\n\n  return target;\n}\n\nfunction emptyChain() {\n  return {\n    options: [],\n    presets: [],\n    plugins: []\n  };\n}\n\nfunction normalizeOptions(opts) {\n  var options = Object.assign({}, opts);\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n\n  if (options.hasOwnProperty(\"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n\n  return options;\n}\n\nfunction dedupDescriptors(items) {\n  var map = new Map();\n  var descriptors = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var item = _step.value;\n\n      if (typeof item.value === \"function\") {\n        var fnKey = item.value;\n        var nameMap = map.get(fnKey);\n\n        if (!nameMap) {\n          nameMap = new Map();\n          map.set(fnKey, nameMap);\n        }\n\n        var desc = nameMap.get(item.name);\n\n        if (!desc) {\n          desc = {\n            value: item\n          };\n          descriptors.push(desc);\n          if (!item.ownPass) nameMap.set(item.name, desc);\n        } else {\n          desc.value = item;\n        }\n      } else {\n        descriptors.push({\n          value: item\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return descriptors.reduce(function (acc, desc) {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\n\nfunction configIsApplicable(_ref9, dirname, context) {\n  var options = _ref9.options;\n  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));\n}\n\nfunction configFieldIsApplicable(context, test, dirname) {\n  var patterns = Array.isArray(test) ? test : [test];\n  return matchesPatterns(context, patterns, dirname);\n}\n\nfunction shouldIgnore(context, ignore, only, dirname) {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    debug(\"Ignored %o because it matched one of %O from %o\", context.filename, ignore, dirname);\n    return true;\n  }\n\n  if (only && !matchesPatterns(context, only, dirname)) {\n    debug(\"Ignored %o because it failed to match one of %O from %o\", context.filename, only, dirname);\n    return true;\n  }\n\n  return false;\n}\n\nfunction matchesPatterns(context, patterns, dirname) {\n  return patterns.some(function (pattern) {\n    return matchPattern(pattern, dirname, context.filename, context);\n  });\n}\n\nfunction matchPattern(pattern, dirname, pathToTest, context) {\n  if (typeof pattern === \"function\") {\n    return !!pattern(pathToTest, {\n      dirname: dirname,\n      envName: context.envName,\n      caller: context.caller\n    });\n  }\n\n  if (typeof pathToTest !== \"string\") {\n    throw new Error(\"Configuration contains string/RegExp pattern, but no filename was passed to Babel\");\n  }\n\n  if (typeof pattern === \"string\") {\n    pattern = (0, _patternToRegex.default)(pattern, dirname);\n  }\n\n  return pattern.test(pathToTest);\n}","map":null,"metadata":{},"sourceType":"script"}