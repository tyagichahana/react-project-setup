{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Wraps a callback style function to conditionally return a promise.\n *\n * @param {function} originalMethod - The method to promisify.\n * @param {object=} options - Promise options.\n * @param {boolean} options.singular - Resolve the promise with single arg instead of an array.\n * @return {function} wrapped\n */\n\nfunction promisify(originalMethod, options) {\n  if (originalMethod.promisified_) {\n    return originalMethod;\n  }\n\n  options = options || {};\n  var slice = Array.prototype.slice; // tslint:disable-next-line:no-any\n\n  var wrapper = function wrapper() {\n    var context = this;\n    var last;\n\n    for (last = arguments.length - 1; last >= 0; last--) {\n      var arg = arguments[last];\n\n      if (typeof arg === 'undefined') {\n        continue; // skip trailing undefined.\n      }\n\n      if (typeof arg !== 'function') {\n        break; // non-callback last argument found.\n      }\n\n      return originalMethod.apply(context, arguments);\n    } // peel trailing undefined.\n\n\n    var args = slice.call(arguments, 0, last + 1); // tslint:disable-next-line:variable-name\n\n    var PromiseCtor = Promise; // Because dedupe will likely create a single install of\n    // @google-cloud/common to be shared amongst all modules, we need to\n    // localize it at the Service level.\n\n    if (context && context.Promise) {\n      PromiseCtor = context.Promise;\n    }\n\n    return new PromiseCtor(function (resolve, reject) {\n      // tslint:disable-next-line:no-any\n      args.push(function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var callbackArgs = slice.call(args);\n        var err = callbackArgs.shift();\n\n        if (err) {\n          return reject(err);\n        }\n\n        if (options.singular && callbackArgs.length === 1) {\n          resolve(callbackArgs[0]);\n        } else {\n          resolve(callbackArgs);\n        }\n      });\n      originalMethod.apply(context, args);\n    });\n  };\n\n  wrapper.promisified_ = true;\n  return wrapper;\n}\n\nexports.promisify = promisify;\n/**\n * Promisifies certain Class methods. This will not promisify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n// tslint:disable-next-line:variable-name\n\nfunction promisifyAll(Class, options) {\n  var exclude = options && options.exclude || [];\n  var ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n  var methods = ownPropertyNames.filter(function (methodName) {\n    // clang-format off\n    return typeof Class.prototype[methodName] === 'function' && // is it a function?\n    !/(^_|(Stream|_)|promise$)|^constructor$/.test(methodName) && // is it promisable?\n    exclude.indexOf(methodName) === -1; // is it blacklisted?\n    // clang-format on\n  });\n  methods.forEach(function (methodName) {\n    var originalMethod = Class.prototype[methodName];\n\n    if (!originalMethod.promisified_) {\n      Class.prototype[methodName] = exports.promisify(originalMethod, options);\n    }\n  });\n}\n\nexports.promisifyAll = promisifyAll;","map":null,"metadata":{},"sourceType":"script"}