{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/chahanatyagi/Work/cm-frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = loadFullConfig;\n\nvar _util = require(\"./util\");\n\nvar context = _interopRequireWildcard(require(\"../index\"));\n\nvar _plugin = _interopRequireDefault(require(\"./plugin\"));\n\nvar _item = require(\"./item\");\n\nvar _configChain = require(\"./config-chain\");\n\nfunction _traverse() {\n  var data = _interopRequireDefault(require(\"@babel/traverse\"));\n\n  _traverse = function _traverse() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"./caching\");\n\nvar _options = require(\"./validation/options\");\n\nvar _plugins = require(\"./validation/plugins\");\n\nvar _configApi = _interopRequireDefault(require(\"./helpers/config-api\"));\n\nvar _partial = _interopRequireDefault(require(\"./partial\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction loadFullConfig(inputOpts) {\n  var result = (0, _partial.default)(inputOpts);\n\n  if (!result) {\n    return null;\n  }\n\n  var options = result.options,\n      context = result.context;\n  var optionDefaults = {};\n  var passes = [[]];\n\n  try {\n    var plugins = options.plugins,\n        presets = options.presets;\n\n    if (!plugins || !presets) {\n      throw new Error(\"Assertion failure - plugins and presets exist\");\n    }\n\n    var ignored = function recurseDescriptors(config, pass) {\n      var plugins = config.plugins.reduce(function (acc, descriptor) {\n        if (descriptor.options !== false) {\n          acc.push(loadPluginDescriptor(descriptor, context));\n        }\n\n        return acc;\n      }, []);\n      var presets = config.presets.reduce(function (acc, descriptor) {\n        if (descriptor.options !== false) {\n          acc.push({\n            preset: loadPresetDescriptor(descriptor, context),\n            pass: descriptor.ownPass ? [] : pass\n          });\n        }\n\n        return acc;\n      }, []);\n\n      if (presets.length > 0) {\n        passes.splice.apply(passes, [1, 0].concat(_toConsumableArray(presets.map(function (o) {\n          return o.pass;\n        }).filter(function (p) {\n          return p !== pass;\n        }))));\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = presets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n            var preset = _ref.preset,\n                _pass = _ref.pass;\n            if (!preset) return true;\n\n            var _ignored = recurseDescriptors({\n              plugins: preset.plugins,\n              presets: preset.presets\n            }, _pass);\n\n            if (_ignored) return true;\n            preset.options.forEach(function (opts) {\n              (0, _util.mergeOptions)(optionDefaults, opts);\n            });\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      if (plugins.length > 0) {\n        pass.unshift.apply(pass, _toConsumableArray(plugins));\n      }\n    }({\n      plugins: plugins.map(function (item) {\n        var desc = (0, _item.getItemDescriptor)(item);\n\n        if (!desc) {\n          throw new Error(\"Assertion failure - must be config item\");\n        }\n\n        return desc;\n      }),\n      presets: presets.map(function (item) {\n        var desc = (0, _item.getItemDescriptor)(item);\n\n        if (!desc) {\n          throw new Error(\"Assertion failure - must be config item\");\n        }\n\n        return desc;\n      })\n    }, passes[0]);\n\n    if (ignored) return null;\n  } catch (e) {\n    if (!/^\\[BABEL\\]/.test(e.message)) {\n      e.message = \"[BABEL] \".concat(context.filename || \"unknown\", \": \").concat(e.message);\n    }\n\n    throw e;\n  }\n\n  var opts = optionDefaults;\n  (0, _util.mergeOptions)(opts, options);\n  opts.plugins = passes[0];\n  opts.presets = passes.slice(1).filter(function (plugins) {\n    return plugins.length > 0;\n  }).map(function (plugins) {\n    return {\n      plugins: plugins\n    };\n  });\n  opts.passPerPreset = opts.presets.length > 0;\n  return {\n    options: opts,\n    passes: passes\n  };\n}\n\nvar loadDescriptor = (0, _caching.makeWeakCache)(function (_ref2, cache) {\n  var value = _ref2.value,\n      options = _ref2.options,\n      dirname = _ref2.dirname,\n      alias = _ref2.alias;\n  if (options === false) throw new Error(\"Assertion failure\");\n  options = options || {};\n  var item = value;\n\n  if (typeof value === \"function\") {\n    var api = Object.assign({}, context, (0, _configApi.default)(cache));\n\n    try {\n      item = value(api, options, dirname);\n    } catch (e) {\n      if (alias) {\n        e.message += \" (While processing: \".concat(JSON.stringify(alias), \")\");\n      }\n\n      throw e;\n    }\n  }\n\n  if (!item || typeof item !== \"object\") {\n    throw new Error(\"Plugin/Preset did not return an object.\");\n  }\n\n  if (typeof item.then === \"function\") {\n    throw new Error(\"You appear to be using an async plugin, \" + \"which your current version of Babel does not support.\" + \"If you're using a published plugin, \" + \"you may need to upgrade your @babel/core version.\");\n  }\n\n  return {\n    value: item,\n    options: options,\n    dirname: dirname,\n    alias: alias\n  };\n});\n\nfunction loadPluginDescriptor(descriptor, context) {\n  if (descriptor.value instanceof _plugin.default) {\n    if (descriptor.options) {\n      throw new Error(\"Passed options to an existing Plugin instance will not work.\");\n    }\n\n    return descriptor.value;\n  }\n\n  return instantiatePlugin(loadDescriptor(descriptor, context), context);\n}\n\nvar instantiatePlugin = (0, _caching.makeWeakCache)(function (_ref3, cache) {\n  var value = _ref3.value,\n      options = _ref3.options,\n      dirname = _ref3.dirname,\n      alias = _ref3.alias;\n  var pluginObj = (0, _plugins.validatePluginObject)(value);\n  var plugin = Object.assign({}, pluginObj);\n\n  if (plugin.visitor) {\n    plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));\n  }\n\n  if (plugin.inherits) {\n    var inheritsDescriptor = {\n      name: undefined,\n      alias: \"\".concat(alias, \"$inherits\"),\n      value: plugin.inherits,\n      options: options,\n      dirname: dirname\n    };\n    var inherits = cache.invalidate(function (data) {\n      return loadPluginDescriptor(inheritsDescriptor, data);\n    });\n    plugin.pre = chain(inherits.pre, plugin.pre);\n    plugin.post = chain(inherits.post, plugin.post);\n    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);\n    plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);\n  }\n\n  return new _plugin.default(plugin, options, alias);\n});\n\nvar loadPresetDescriptor = function loadPresetDescriptor(descriptor, context) {\n  return (0, _configChain.buildPresetChain)(instantiatePreset(loadDescriptor(descriptor, context)), context);\n};\n\nvar instantiatePreset = (0, _caching.makeWeakCache)(function (_ref4) {\n  var value = _ref4.value,\n      dirname = _ref4.dirname,\n      alias = _ref4.alias;\n  return {\n    options: (0, _options.validate)(\"preset\", value),\n    alias: alias,\n    dirname: dirname\n  };\n});\n\nfunction chain(a, b) {\n  var fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = fns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var fn = _step2.value;\n        fn.apply(this, args);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"script"}