{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeFile;\n\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  var data = _interopRequireDefault(require(\"debug\"));\n\n  _debug = function _debug() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cloneDeep() {\n  var data = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\n  _cloneDeep = function _cloneDeep() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction t() {\n  var data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function t() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  var data = _interopRequireDefault(require(\"convert-source-map\"));\n\n  _convertSourceMap = function _convertSourceMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _parser() {\n  var data = require(\"@babel/parser\");\n\n  _parser = function _parser() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _codeFrame() {\n  var data = require(\"@babel/code-frame\");\n\n  _codeFrame = function _codeFrame() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _file = _interopRequireDefault(require(\"./file/file\"));\n\nvar _missingPluginHelper = _interopRequireDefault(require(\"./util/missing-plugin-helper\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar debug = (0, _debug().default)(\"babel:transform:file\");\n\nfunction normalizeFile(pluginPasses, options, code, ast) {\n  code = \"\".concat(code || \"\");\n  var inputMap = null;\n\n  if (options.inputSourceMap !== false) {\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = _convertSourceMap().default.fromObject(options.inputSourceMap);\n    }\n\n    if (!inputMap) {\n      try {\n        inputMap = _convertSourceMap().default.fromSource(code);\n\n        if (inputMap) {\n          code = _convertSourceMap().default.removeComments(code);\n        }\n      } catch (err) {\n        debug(\"discarding unknown inline input sourcemap\", err);\n        code = _convertSourceMap().default.removeComments(code);\n      }\n    }\n\n    if (!inputMap) {\n      if (typeof options.filename === \"string\") {\n        try {\n          inputMap = _convertSourceMap().default.fromMapFileSource(code, _path().default.dirname(options.filename));\n\n          if (inputMap) {\n            code = _convertSourceMap().default.removeMapFileComments(code);\n          }\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n          code = _convertSourceMap().default.removeMapFileComments(code);\n        }\n      } else {\n        debug(\"discarding un-loadable file input sourcemap\");\n        code = _convertSourceMap().default.removeMapFileComments(code);\n      }\n    }\n  }\n\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = t().file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n\n    ast = (0, _cloneDeep().default)(ast);\n  } else {\n    ast = parser(pluginPasses, options, code);\n  }\n\n  return new _file.default(options, {\n    code: code,\n    ast: ast,\n    inputMap: inputMap\n  });\n}\n\nfunction parser(pluginPasses, _ref, code) {\n  var parserOpts = _ref.parserOpts,\n      _ref$highlightCode = _ref.highlightCode,\n      highlightCode = _ref$highlightCode === void 0 ? true : _ref$highlightCode,\n      _ref$filename = _ref.filename,\n      filename = _ref$filename === void 0 ? \"unknown\" : _ref$filename;\n\n  try {\n    var results = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = pluginPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var plugins = _step.value;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var plugin = _step2.value;\n            var parserOverride = plugin.parserOverride;\n\n            if (parserOverride) {\n              var ast = parserOverride(code, parserOpts, _parser().parse);\n              if (ast !== undefined) results.push(ast);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (results.length === 0) {\n      return (0, _parser().parse)(code, parserOpts);\n    } else if (results.length === 1) {\n      if (typeof results[0].then === \"function\") {\n        throw new Error(\"You appear to be using an async codegen plugin, \" + \"which your current version of Babel does not support. \" + \"If you're using a published plugin, you may need to upgrade \" + \"your @babel/core version.\");\n      }\n\n      return results[0];\n    }\n\n    throw new Error(\"More than one plugin attempted to override parsing.\");\n  } catch (err) {\n    if (err.code === \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\") {\n      err.message += \"\\nConsider renaming the file to '.mjs', or setting sourceType:module \" + \"or sourceType:unambiguous in your Babel config for this file.\";\n    }\n\n    var loc = err.loc,\n        missingPlugin = err.missingPlugin;\n\n    if (loc) {\n      var codeFrame = (0, _codeFrame().codeFrameColumns)(code, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      }, {\n        highlightCode: highlightCode\n      });\n\n      if (missingPlugin) {\n        err.message = \"\".concat(filename, \": \") + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame);\n      } else {\n        err.message = \"\".concat(filename, \": \").concat(err.message, \"\\n\\n\") + codeFrame;\n      }\n\n      err.code = \"BABEL_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}