{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/chahanatyagi/Work/cm-frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/chahanatyagi/Work/cm-frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/chahanatyagi/Work/cm-frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction t() {\n  var data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function t() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nvar referenceVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t().react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      var scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    var binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n};\n\nvar PathHoister =\n/*#__PURE__*/\nfunction () {\n  function PathHoister(path, scope) {\n    _classCallCheck(this, PathHoister);\n\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  _createClass(PathHoister, [{\n    key: \"isCompatibleScope\",\n    value: function isCompatibleScope(scope) {\n      for (var key in this.bindings) {\n        var binding = this.bindings[key];\n\n        if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"getCompatibleScopes\",\n    value: function getCompatibleScopes() {\n      var scope = this.path.scope;\n\n      do {\n        if (this.isCompatibleScope(scope)) {\n          this.scopes.push(scope);\n        } else {\n          break;\n        }\n\n        if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n          break;\n        }\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"getAttachmentPath\",\n    value: function getAttachmentPath() {\n      var path = this._getAttachmentPath();\n\n      if (!path) return;\n      var targetScope = path.scope;\n\n      if (targetScope.path === path) {\n        targetScope = path.scope.parent;\n      }\n\n      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n        for (var name in this.bindings) {\n          if (!targetScope.hasOwnBinding(name)) continue;\n          var binding = this.bindings[name];\n\n          if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n            continue;\n          }\n\n          var bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n          if (bindingParentPath.key >= path.key) {\n            this.attachAfter = true;\n            path = binding.path;\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = binding.constantViolations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var violationPath = _step.value;\n\n                if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n                  path = violationPath;\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return path;\n    }\n  }, {\n    key: \"_getAttachmentPath\",\n    value: function _getAttachmentPath() {\n      var scopes = this.scopes;\n      var scope = scopes.pop();\n      if (!scope) return;\n\n      if (scope.path.isFunction()) {\n        if (this.hasOwnParamBindings(scope)) {\n          if (this.scope === scope) return;\n          var bodies = scope.path.get(\"body\").get(\"body\");\n\n          for (var i = 0; i < bodies.length; i++) {\n            if (bodies[i].node._blockHoist) continue;\n            return bodies[i];\n          }\n        } else {\n          return this.getNextScopeAttachmentParent();\n        }\n      } else if (scope.path.isProgram()) {\n        return this.getNextScopeAttachmentParent();\n      }\n    }\n  }, {\n    key: \"getNextScopeAttachmentParent\",\n    value: function getNextScopeAttachmentParent() {\n      var scope = this.scopes.pop();\n      if (scope) return this.getAttachmentParentForPath(scope.path);\n    }\n  }, {\n    key: \"getAttachmentParentForPath\",\n    value: function getAttachmentParentForPath(path) {\n      do {\n        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n          return path;\n        }\n      } while (path = path.parentPath);\n    }\n  }, {\n    key: \"hasOwnParamBindings\",\n    value: function hasOwnParamBindings(scope) {\n      for (var name in this.bindings) {\n        if (!scope.hasOwnBinding(name)) continue;\n        var binding = this.bindings[name];\n        if (binding.kind === \"param\" && binding.constant) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      this.path.traverse(referenceVisitor, this);\n      this.getCompatibleScopes();\n      var attachTo = this.getAttachmentPath();\n      if (!attachTo) return;\n      if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n      var uid = attachTo.scope.generateUidIdentifier(\"ref\");\n      var declarator = t().variableDeclarator(uid, this.path.node);\n      var insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n\n      var _attachTo$insertFn = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t().variableDeclaration(\"var\", [declarator])]),\n          _attachTo$insertFn2 = _slicedToArray(_attachTo$insertFn, 1),\n          attached = _attachTo$insertFn2[0];\n\n      var parent = this.path.parentPath;\n\n      if (parent.isJSXElement() && this.path.container === parent.node.children) {\n        uid = t().JSXExpressionContainer(uid);\n      }\n\n      this.path.replaceWith(t().cloneNode(uid));\n      return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n    }\n  }]);\n\n  return PathHoister;\n}();\n\nexports.default = PathHoister;","map":null,"metadata":{},"sourceType":"script"}