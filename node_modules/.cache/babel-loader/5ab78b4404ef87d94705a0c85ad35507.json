{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/chahanatyagi/Work/cm-frontend/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/chahanatyagi/Work/cm-frontend/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _isInteger() {\n  var data = _interopRequireDefault(require(\"lodash/isInteger\"));\n\n  _isInteger = function _isInteger() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _repeat() {\n  var data = _interopRequireDefault(require(\"lodash/repeat\"));\n\n  _repeat = function _repeat() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _buffer = _interopRequireDefault(require(\"./buffer\"));\n\nvar n = _interopRequireWildcard(require(\"./node\"));\n\nfunction t() {\n  var data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function t() {\n    return data;\n  };\n\n  return data;\n}\n\nvar generatorFunctions = _interopRequireWildcard(require(\"./generators\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar SCIENTIFIC_NOTATION = /e/i;\nvar ZERO_DECIMAL_INTEGER = /\\.0+$/;\nvar NON_DECIMAL_LITERAL = /^0[box]/;\n\nvar Printer =\n/*#__PURE__*/\nfunction () {\n  function Printer(format, map) {\n    _classCallCheck(this, Printer);\n\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._printedCommentStarts = {};\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format || {};\n    this._buf = new _buffer.default(map);\n  }\n\n  _createClass(Printer, [{\n    key: \"generate\",\n    value: function generate(ast) {\n      this.print(ast);\n\n      this._maybeAddAuxComment();\n\n      return this._buf.get();\n    }\n  }, {\n    key: \"indent\",\n    value: function indent() {\n      if (this.format.compact || this.format.concise) return;\n      this._indent++;\n    }\n  }, {\n    key: \"dedent\",\n    value: function dedent() {\n      if (this.format.compact || this.format.concise) return;\n      this._indent--;\n    }\n  }, {\n    key: \"semicolon\",\n    value: function semicolon() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      this._maybeAddAuxComment();\n\n      this._append(\";\", !force);\n    }\n  }, {\n    key: \"rightBrace\",\n    value: function rightBrace() {\n      if (this.format.minified) {\n        this._buf.removeLastSemicolon();\n      }\n\n      this.token(\"}\");\n    }\n  }, {\n    key: \"space\",\n    value: function space() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.format.compact) return;\n\n      if (this._buf.hasContent() && !this.endsWith(\" \") && !this.endsWith(\"\\n\") || force) {\n        this._space();\n      }\n    }\n  }, {\n    key: \"word\",\n    value: function word(str) {\n      if (this._endsWithWord || this.endsWith(\"/\") && str.indexOf(\"/\") === 0) {\n        this._space();\n      }\n\n      this._maybeAddAuxComment();\n\n      this._append(str);\n\n      this._endsWithWord = true;\n    }\n  }, {\n    key: \"number\",\n    value: function number(str) {\n      this.word(str);\n      this._endsWithInteger = (0, _isInteger().default)(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== \".\";\n    }\n  }, {\n    key: \"token\",\n    value: function token(str) {\n      if (str === \"--\" && this.endsWith(\"!\") || str[0] === \"+\" && this.endsWith(\"+\") || str[0] === \"-\" && this.endsWith(\"-\") || str[0] === \".\" && this._endsWithInteger) {\n        this._space();\n      }\n\n      this._maybeAddAuxComment();\n\n      this._append(str);\n    }\n  }, {\n    key: \"newline\",\n    value: function newline(i) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n\n      if (this.endsWith(\"\\n\\n\")) return;\n      if (typeof i !== \"number\") i = 1;\n      i = Math.min(2, i);\n      if (this.endsWith(\"{\\n\") || this.endsWith(\":\\n\")) i--;\n      if (i <= 0) return;\n\n      for (var j = 0; j < i; j++) {\n        this._newline();\n      }\n    }\n  }, {\n    key: \"endsWith\",\n    value: function endsWith(str) {\n      return this._buf.endsWith(str);\n    }\n  }, {\n    key: \"removeTrailingNewline\",\n    value: function removeTrailingNewline() {\n      this._buf.removeTrailingNewline();\n    }\n  }, {\n    key: \"exactSource\",\n    value: function exactSource(loc, cb) {\n      this._catchUp(\"start\", loc);\n\n      this._buf.exactSource(loc, cb);\n    }\n  }, {\n    key: \"source\",\n    value: function source(prop, loc) {\n      this._catchUp(prop, loc);\n\n      this._buf.source(prop, loc);\n    }\n  }, {\n    key: \"withSource\",\n    value: function withSource(prop, loc, cb) {\n      this._catchUp(prop, loc);\n\n      this._buf.withSource(prop, loc, cb);\n    }\n  }, {\n    key: \"_space\",\n    value: function _space() {\n      this._append(\" \", true);\n    }\n  }, {\n    key: \"_newline\",\n    value: function _newline() {\n      this._append(\"\\n\", true);\n    }\n  }, {\n    key: \"_append\",\n    value: function _append(str) {\n      var queue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      this._maybeAddParen(str);\n\n      this._maybeIndent(str);\n\n      if (queue) this._buf.queue(str);else this._buf.append(str);\n      this._endsWithWord = false;\n      this._endsWithInteger = false;\n    }\n  }, {\n    key: \"_maybeIndent\",\n    value: function _maybeIndent(str) {\n      if (this._indent && this.endsWith(\"\\n\") && str[0] !== \"\\n\") {\n        this._buf.queue(this._getIndent());\n      }\n    }\n  }, {\n    key: \"_maybeAddParen\",\n    value: function _maybeAddParen(str) {\n      var parenPushNewlineState = this._parenPushNewlineState;\n      if (!parenPushNewlineState) return;\n      this._parenPushNewlineState = null;\n      var i;\n\n      for (i = 0; i < str.length && str[i] === \" \"; i++) {\n        continue;\n      }\n\n      if (i === str.length) return;\n      var cha = str[i];\n\n      if (cha !== \"\\n\") {\n        if (cha !== \"/\") return;\n        if (i + 1 === str.length) return;\n        var chaPost = str[i + 1];\n        if (chaPost !== \"/\" && chaPost !== \"*\") return;\n      }\n\n      this.token(\"(\");\n      this.indent();\n      parenPushNewlineState.printed = true;\n    }\n  }, {\n    key: \"_catchUp\",\n    value: function _catchUp(prop, loc) {\n      if (!this.format.retainLines) return;\n      var pos = loc ? loc[prop] : null;\n\n      if (pos && pos.line !== null) {\n        var count = pos.line - this._buf.getCurrentLine();\n\n        for (var i = 0; i < count; i++) {\n          this._newline();\n        }\n      }\n    }\n  }, {\n    key: \"_getIndent\",\n    value: function _getIndent() {\n      return (0, _repeat().default)(this.format.indent.style, this._indent);\n    }\n  }, {\n    key: \"startTerminatorless\",\n    value: function startTerminatorless() {\n      var isLabel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (isLabel) {\n        this._noLineTerminator = true;\n        return null;\n      } else {\n        return this._parenPushNewlineState = {\n          printed: false\n        };\n      }\n    }\n  }, {\n    key: \"endTerminatorless\",\n    value: function endTerminatorless(state) {\n      this._noLineTerminator = false;\n\n      if (state && state.printed) {\n        this.dedent();\n        this.newline();\n        this.token(\")\");\n      }\n    }\n  }, {\n    key: \"print\",\n    value: function print(node, parent) {\n      var _this = this;\n\n      if (!node) return;\n      var oldConcise = this.format.concise;\n\n      if (node._compact) {\n        this.format.concise = true;\n      }\n\n      var printMethod = this[node.type];\n\n      if (!printMethod) {\n        throw new ReferenceError(\"unknown node of type \".concat(JSON.stringify(node.type), \" with constructor \").concat(JSON.stringify(node && node.constructor.name)));\n      }\n\n      this._printStack.push(node);\n\n      var oldInAux = this._insideAux;\n      this._insideAux = !node.loc;\n\n      this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n      var needsParens = n.needsParens(node, parent, this._printStack);\n\n      if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n        needsParens = true;\n      }\n\n      if (needsParens) this.token(\"(\");\n\n      this._printLeadingComments(node);\n\n      var loc = t().isProgram(node) || t().isFile(node) ? null : node.loc;\n      this.withSource(\"start\", loc, function () {\n        _this[node.type](node, parent);\n      });\n\n      this._printTrailingComments(node);\n\n      if (needsParens) this.token(\")\");\n\n      this._printStack.pop();\n\n      this.format.concise = oldConcise;\n      this._insideAux = oldInAux;\n    }\n  }, {\n    key: \"_maybeAddAuxComment\",\n    value: function _maybeAddAuxComment(enteredPositionlessNode) {\n      if (enteredPositionlessNode) this._printAuxBeforeComment();\n      if (!this._insideAux) this._printAuxAfterComment();\n    }\n  }, {\n    key: \"_printAuxBeforeComment\",\n    value: function _printAuxBeforeComment() {\n      if (this._printAuxAfterOnNextUserNode) return;\n      this._printAuxAfterOnNextUserNode = true;\n      var comment = this.format.auxiliaryCommentBefore;\n\n      if (comment) {\n        this._printComment({\n          type: \"CommentBlock\",\n          value: comment\n        });\n      }\n    }\n  }, {\n    key: \"_printAuxAfterComment\",\n    value: function _printAuxAfterComment() {\n      if (!this._printAuxAfterOnNextUserNode) return;\n      this._printAuxAfterOnNextUserNode = false;\n      var comment = this.format.auxiliaryCommentAfter;\n\n      if (comment) {\n        this._printComment({\n          type: \"CommentBlock\",\n          value: comment\n        });\n      }\n    }\n  }, {\n    key: \"getPossibleRaw\",\n    value: function getPossibleRaw(node) {\n      var extra = node.extra;\n\n      if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n        return extra.raw;\n      }\n    }\n  }, {\n    key: \"printJoin\",\n    value: function printJoin(nodes, parent) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!nodes || !nodes.length) return;\n      if (opts.indent) this.indent();\n      var newlineOpts = {\n        addNewlines: opts.addNewlines\n      };\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (!node) continue;\n        if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n        this.print(node, parent);\n\n        if (opts.iterator) {\n          opts.iterator(node, i);\n        }\n\n        if (opts.separator && i < nodes.length - 1) {\n          opts.separator.call(this);\n        }\n\n        if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n      }\n\n      if (opts.indent) this.dedent();\n    }\n  }, {\n    key: \"printAndIndentOnComments\",\n    value: function printAndIndentOnComments(node, parent) {\n      var indent = node.leadingComments && node.leadingComments.length > 0;\n      if (indent) this.indent();\n      this.print(node, parent);\n      if (indent) this.dedent();\n    }\n  }, {\n    key: \"printBlock\",\n    value: function printBlock(parent) {\n      var node = parent.body;\n\n      if (!t().isEmptyStatement(node)) {\n        this.space();\n      }\n\n      this.print(node, parent);\n    }\n  }, {\n    key: \"_printTrailingComments\",\n    value: function _printTrailingComments(node) {\n      this._printComments(this._getComments(false, node));\n    }\n  }, {\n    key: \"_printLeadingComments\",\n    value: function _printLeadingComments(node) {\n      this._printComments(this._getComments(true, node));\n    }\n  }, {\n    key: \"printInnerComments\",\n    value: function printInnerComments(node) {\n      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (!node.innerComments || !node.innerComments.length) return;\n      if (indent) this.indent();\n\n      this._printComments(node.innerComments);\n\n      if (indent) this.dedent();\n    }\n  }, {\n    key: \"printSequence\",\n    value: function printSequence(nodes, parent) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.statement = true;\n      return this.printJoin(nodes, parent, opts);\n    }\n  }, {\n    key: \"printList\",\n    value: function printList(items, parent) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (opts.separator == null) {\n        opts.separator = commaSeparator;\n      }\n\n      return this.printJoin(items, parent, opts);\n    }\n  }, {\n    key: \"_printNewline\",\n    value: function _printNewline(leading, node, parent, opts) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n\n      var lines = 0;\n\n      if (this._buf.hasContent()) {\n        if (!leading) lines++;\n        if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n        var needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;\n        if (needs(node, parent)) lines++;\n      }\n\n      this.newline(lines);\n    }\n  }, {\n    key: \"_getComments\",\n    value: function _getComments(leading, node) {\n      return node && (leading ? node.leadingComments : node.trailingComments) || [];\n    }\n  }, {\n    key: \"_printComment\",\n    value: function _printComment(comment) {\n      var _this2 = this;\n\n      if (!this.format.shouldPrintComment(comment.value)) return;\n      if (comment.ignore) return;\n      if (this._printedComments.has(comment)) return;\n\n      this._printedComments.add(comment);\n\n      if (comment.start != null) {\n        if (this._printedCommentStarts[comment.start]) return;\n        this._printedCommentStarts[comment.start] = true;\n      }\n\n      var isBlockComment = comment.type === \"CommentBlock\";\n      this.newline(this._buf.hasContent() && !this._noLineTerminator && isBlockComment ? 1 : 0);\n      if (!this.endsWith(\"[\") && !this.endsWith(\"{\")) this.space();\n      var val = !isBlockComment && !this._noLineTerminator ? \"//\".concat(comment.value, \"\\n\") : \"/*\".concat(comment.value, \"*/\");\n\n      if (isBlockComment && this.format.indent.adjustMultilineComment) {\n        var offset = comment.loc && comment.loc.start.column;\n\n        if (offset) {\n          var newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n\n        var indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());\n        val = val.replace(/\\n(?!$)/g, \"\\n\".concat((0, _repeat().default)(\" \", indentSize)));\n      }\n\n      if (this.endsWith(\"/\")) this._space();\n      this.withSource(\"start\", comment.loc, function () {\n        _this2._append(val);\n      });\n      this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);\n    }\n  }, {\n    key: \"_printComments\",\n    value: function _printComments(comments) {\n      if (!comments || !comments.length) return;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = comments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var comment = _step.value;\n\n          this._printComment(comment);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Printer;\n}();\n\nexports.default = Printer;\nObject.assign(Printer.prototype, generatorFunctions);\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}","map":null,"metadata":{},"sourceType":"script"}